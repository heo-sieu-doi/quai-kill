<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H·ªá Th·ªëng Qu·∫£n L√Ω SƒÉn Qu√°i FvN</title>
    <!-- Th√™m v√†o ph·∫ßn head -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js">
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* --- Bi·∫øn v√† Thi·∫øt l·∫≠p C∆° b·∫£n --- */
        :root {
            --primary-color: #3498db;
            --success-color: #2ecc71;
            --warning-color: #f1c40f;
            --danger-color: #e74c3c;
            --info-color: #9b59b6;
            /* M√†u cho n√∫t export ·∫£nh */
            --secondary-color: #95a5a6;
            /* M√†u cho n√∫t toggle */
            --light-gray: #ecf0f1;
            --medium-gray: #bdc3c7;
            --dark-gray: #7f8c8d;
            --text-color: #34495e;
            --bg-color: #f4f7f9;
            /* N·ªÅn h∆°i x√°m nh·∫π */
            --white-color: #ffffff;
            --border-radius-sm: 4px;
            --border-radius-md: 8px;
            --box-shadow-light: 0 2px 5px rgba(0, 0, 0, 0.08);
            --box-shadow-medium: 0 4px 12px rgba(0, 0, 0, 0.1);
            --transition-speed: 0.2s;
        }

        body {
            font-family: 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            /* X√≥a margin m·∫∑c ƒë·ªãnh */
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        /* --- Container Ch√≠nh --- */
        .main-container {
            max-width: 1400px;
            /* Gi·ªõi h·∫°n chi·ªÅu r·ªông t·ªëi ƒëa */
            margin: 20px auto;
            /* CƒÉn gi·ªØa v√† t·∫°o kho·∫£ng c√°ch tr√™n/d∆∞·ªõi */
            padding: 0 20px;
            /* Padding hai b√™n */
        }

        /* --- Header --- */
        .header {
            background-color: var(--white-color);
            padding: 20px;
            border-radius: var(--border-radius-md);
            box-shadow: var(--box-shadow-light);
            display: flex;
            flex-wrap: wrap;
            /* Cho ph√©p wrap tr√™n m√†n h√¨nh nh·ªè */
            align-items: center;
            gap: 20px;
            margin-bottom: 25px;
            max-width: 1400px;
            /* Gi·ªõi h·∫°n chi·ªÅu r·ªông */
            margin-left: auto;
            /* CƒÉn gi·ªØa */
            margin-right: auto;
            /* CƒÉn gi·ªØa */
        }

        /* === TH√äM M·ªöI: Style cho √¥ th·ªëng k√™ header === */
        .header-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #eef2f5;
            /* M√†u n·ªÅn h∆°i kh√°c m·ªôt ch√∫t */
            padding: 8px 18px;
            border-radius: var(--border-radius-md);
            text-align: center;
            border: 1px solid var(--light-gray);
            margin-left: 20px;
            /* Th√™m kho·∫£ng c√°ch v·ªõi ti√™u ƒë·ªÅ */
        }

        .stat-label {
            font-size: 13px;
            color: var(--dark-gray);
            font-weight: 600;
            margin-bottom: 2px;
        }

        .stat-value {
            font-size: 1.6em;
            font-weight: 700;
            color: var(--primary-color);
            line-height: 1.1;
        }

        .title-wrapper h1 {
            font-size: 1.8em;
            /* Gi·∫£m nh·∫π k√≠ch th∆∞·ªõc */
            color: var(--primary-color);
            text-shadow: none;
            margin: 0;
            /* X√≥a margin m·∫∑c ƒë·ªãnh c·ªßa h1 */
            white-space: nowrap;
            /* NgƒÉn kh√¥ng cho ti√™u ƒë·ªÅ xu·ªëng d√≤ng */
        }

        .input-actions-group {
            display: flex;
            flex-wrap: wrap;
            /* Cho ph√©p wrap */
            gap: 15px;
            align-items: center;
            /* CƒÉn gi·ªØa c√°c item */
            flex-grow: 1;
            /* Cho ph√©p nh√≥m n√†y m·ªü r·ªông */
            justify-content: flex-end;
            /* ƒê·∫©y v·ªÅ b√™n ph·∫£i */
            align-items: flex-start;
            /* C√≥ th·ªÉ c·∫ßn ƒëi·ªÅu ch·ªânh alignment */
        }

        .input-group {
            display: flex;
            gap: 10px;
            min-width: 250px;
            /* ƒê·∫£m b·∫£o ƒë·ªß r·ªông */
            flex-grow: 1;
            /* Cho ph√©p input URL m·ªü r·ªông */
            max-width: 400px;
            /* Gi·ªõi h·∫°n chi·ªÅu r·ªông t·ªëi ƒëa */
        }

        .url-input {
            flex-grow: 1;
            padding: 10px 12px;
            border: 1px solid var(--medium-gray);
            border-radius: var(--border-radius-md);
            font-size: 14px;
            transition: border-color var(--transition-speed);
        }

        .url-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        .file-upload-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        /* --- N√∫t B·∫•m Chung --- */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: var(--border-radius-md);
            cursor: pointer;
            transition: background-color var(--transition-speed), transform var(--transition-speed), box-shadow var(--transition-speed);
            font-weight: 600;
            font-size: 14px;
            text-align: center;
            display: inline-flex;
            /* ƒê·ªÉ cƒÉn ch·ªânh icon n·∫øu c√≥ */
            align-items: center;
            justify-content: center;
            line-height: 1.5;
            /* ƒê·∫£m b·∫£o chi·ªÅu cao nh·∫•t qu√°n */
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .btn:active {
            transform: translateY(0px);
            box-shadow: none;
        }

        /* N√∫t Ch√≠nh (T·∫£i URL, X·ª≠ l√Ω TXT, T·∫°o Bi·ªÉu ƒë·ªì) */
        .btn-primary {
            background-color: var(--primary-color);
            color: var(--white-color);
        }

        .btn-primary:hover {
            background-color: #2980b9;
            /* M√†u t·ªëi h∆°n ch√∫t */
        }

        /* N√∫t Th√†nh C√¥ng (Xu·∫•t Excel) */
        .btn-success {
            background-color: var(--success-color);
            color: var(--white-color);
        }

        .btn-success:hover {
            background-color: #27ae60;
        }

        /* N√∫t Export ·∫¢nh */
        .btn-export {
            background-color: var(--info-color);
            color: var(--white-color);
        }

        .btn-export:hover {
            background-color: #8e44ad;
        }

        /* N√∫t Toggle (·∫®n/Hi·ªán) */
        .btn-toggle {
            background-color: var(--secondary-color);
            color: var(--white-color);
        }

        .btn-toggle:hover {
            background-color: #7f8c8d;
        }

        /* --- File Upload Labels (Gi·ªØ nguy√™n style ƒë·∫πp s·∫µn c√≥) --- */
        .upload-label {
            display: inline-flex;
            align-items: center;
            padding: 10px 15px;
            /* Gi·∫£m padding ch√∫t */
            border-radius: var(--border-radius-md);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            font-size: 14px;
            /* ƒê·ªìng b·ªô font size */
        }

        /* ... (gi·ªØ nguy√™n style .excel-label, .txt-label v√† ::before) ... */
        .excel-label {
            background: #217346;
            color: white;
            border: 1px solid #1a5f38;
        }

        .excel-label:hover {
            background: #1a5f38;
            transform: translateY(-1px);
        }

        .excel-label::before {
            content: "üìä";
            margin-right: 8px;
            font-size: 16px;
        }

        .txt-label {
            background: #e67e22;
            color: white;
            border: 1px solid #d35400;
        }

        .txt-label:hover {
            background: #d35400;
            transform: translateY(-1px);
        }

        .txt-label::before {
            content: "üìÑ";
            margin-right: 8px;
            font-size: 16px;
        }

        .file-name {
            margin-left: 10px;
            font-size: 13px;
            /* Nh·ªè h∆°n ch√∫t */
            color: var(--dark-gray);
            font-style: italic;
        }

        input[type="file"] {
            /* ·∫®n input g·ªëc */
            width: 0.1px;
            height: 0.1px;
            opacity: 0;
            overflow: hidden;
            position: absolute;
            z-index: -1;
        }

        /* --- Toolbar v√† Tabs --- */
        .toolbar {
            margin: 25px 0;
            display: flex;
            flex-wrap: wrap;
            /* Cho ph√©p wrap */
            gap: 10px;
            align-items: center;
        }

        /* === TH√äM M·ªöI: Style cho √¥ t√¨m ki·∫øm === */
        .search-group {
            flex-grow: 1;
            /* Cho ph√©p √¥ t√¨m ki·∫øm co gi√£n */
            min-width: 200px;
            /* ƒê·ªô r·ªông t·ªëi thi·ªÉu */
        }

        #searchInput {
            width: 100%;
            /* Chi·∫øm to√†n b·ªô chi·ªÅu r·ªông c·ªßa .search-group */
            box-sizing: border-box;
            /* ƒê·∫£m b·∫£o padding kh√¥ng l√†m tr√†n */
        }

        /* === K·∫æT TH√öC TH√äM M·ªöI === */

        .tab {
            display: flex;
            gap: 5px;
            background: var(--white-color);
            border-radius: var(--border-radius-md);
            padding: 5px;
            box-shadow: var(--box-shadow-light);
            margin-left: auto;
            /* ƒê·∫©y tab sang ph·∫£i */
        }

        .tab button {
            /* Style cho n√∫t trong tab */
            padding: 8px 18px;
            /* Gi·∫£m padding */
            background: none;
            color: var(--text-color);
            border-radius: var(--border-radius-sm);
            /* Bo g√≥c √≠t h∆°n */
            font-weight: 500;
            /* Gi·∫£m ƒë·ªô ƒë·∫≠m */
            box-shadow: none;
            /* B·ªè shadow m·∫∑c ƒë·ªãnh c·ªßa .btn */
        }

        .tab button:hover {
            background-color: var(--light-gray);
            transform: none;
            /* B·ªè hi·ªáu ·ª©ng transform */
            box-shadow: none;
        }

        .tab button.active {
            background: var(--primary-color);
            /* D√πng m√†u primary */
            color: var(--white-color);
            font-weight: 600;
            /* ƒê·∫≠m h∆°n khi active */
        }

        /* --- Tab Content --- */
        .tab-content {
            margin-top: 20px;
            background: var(--white-color);
            border-radius: var(--border-radius-md);
            padding: 20px;
            box-shadow: var(--box-shadow-medium);
            /* Th√™m transition ƒë·ªÉ ·∫©n hi·ªán m∆∞·ª£t h∆°n (n·∫øu mu·ªën) */
            /* transition: opacity 0.3s ease, visibility 0.3s ease; */
        }

        .tab-content-hidden {
            display: none;
            /* Class ƒë·ªÉ ·∫©n tab */
            /* opacity: 0; */
            /* visibility: hidden; */
        }

        /* --- B·∫£ng D·ªØ li·ªáu --- */
        .table-responsive {
            width: 100%;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            border: 1px solid var(--light-gray);
            /* Th√™m vi·ªÅn nh·∫π */
            border-radius: var(--border-radius-md);
            margin-bottom: 1rem;
        }

        .table-responsive>table {
            min-width: 800px;
            width: 100%;
            border-collapse: collapse;
            /* ƒê·∫£m b·∫£o border collapse */
            margin-top: 0;
            /* X√≥a margin top m·∫∑c ƒë·ªãnh */
            table-layout: fixed;
        }

        th,
        td {
            padding: 12px 15px;
            /* TƒÉng padding cho tho√°ng */
            text-align: center;
            border-bottom: 1px solid var(--light-gray);
            white-space: nowrap;
            /* NgƒÉn n·ªôi dung cell xu·ªëng d√≤ng */
        }

        th {
            background: #e9edf0;
            /* M√†u n·ªÅn header nh·∫°t h∆°n */
            color: var(--text-color);
            /* M√†u ch·ªØ t·ªëi h∆°n */
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
            border-bottom-width: 2px;
            /* ƒê∆∞·ªùng k·∫ª d∆∞·ªõi header ƒë·∫≠m h∆°n */
            border-bottom-color: var(--medium-gray);
        }

        tbody tr:nth-child(even) {
            background-color: #f9fafb;
            /* Zebra striping */
        }

        tbody tr:hover {
            background-color: #f0f4f8;
            /* Hi·ªáu ·ª©ng hover */
        }

        /* === TH√äM M·ªöI: Style cho d√≤ng t·ªïng k·∫øt === */
        .table-summary-row td {
            font-weight: bold;
            background-color: #e9edf0; /* Gi·ªëng m√†u header */
            border-top: 2px solid var(--medium-gray);
            color: var(--text-color);
        }

        /* Input trong b·∫£ng */
        .target-input {
            width: 70px;
            padding: 6px 8px;
            border: 1px solid var(--medium-gray);
            border-radius: var(--border-radius-sm);
            text-align: center;
            font-size: 14px;
            transition: border-color var(--transition-speed);
        }

        .target-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        /* Footer c·ªßa b·∫£ng (n√∫t c·∫≠p nh·∫≠t) */
        .table-footer {
            margin-top: 15px;
            text-align: left;
        }

        .table-footer button {
            /* Style ri√™ng cho n√∫t n√†y */
            background: var(--warning-color);
            color: var(--white-color);
            padding: 8px 15px;
            font-size: 14px;
        }

        .table-footer button:hover {
            background: #e67e22;
            /* M√†u t·ªëi h∆°n */
        }

        /* Style c·ªôt cu·ªëi (Thi·∫øu/D∆∞/B√π) */
        td:nth-last-child(1),
        td:nth-last-child(2) {
            font-weight: 600;
            color: var(--danger-color);
        }


        /* ·∫®n c·ªôt cu·ªëi tab Sufficient */
        #sufficientContent .table-responsive>table td:nth-last-child(1),
        #sufficientContent .table-responsive>table th:nth-last-child(1) {
            display: none;
        }

        /* Style cho tab Corrected */
        #correctedContent .table-responsive>table {
            border: 1px dashed var(--primary-color);
            /* ƒê·ªïi th√†nh dashed */
        }

        #correctedContent .table-responsive>table td {
            color: var(--dark-gray);
            font-style: italic;
        }

        #correctedContent .table-responsive>table td:nth-last-child(1),
        #correctedContent .table-responsive>table td:nth-last-child(2) {
            font-weight: bold;
            color: var(--danger-color);
            font-style: normal;
            /* B·ªè italic cho c·ªôt n√†y */
        }

        #correctedContent .table-responsive>table th:nth-last-child(1),
        #correctedContent .table-responsive>table th:nth-last-child(2) {
            background-color: var(--warning-color);
            color: var(--white-color);
        }

        /* --- Bi·ªÉu ƒë·ªì --- */
        .chart-section {
            /* Thay th·∫ø style inline */
            margin-top: 30px;
            background: var(--white-color);
            border-radius: var(--border-radius-md);
            padding: 30px;
            box-shadow: var(--box-shadow-medium);
            border: 1px solid var(--light-gray);
            /* Th√™m vi·ªÅn nh·∫π */
        }

        .chart-section h2 {
            text-align: center;
            margin-top: 0;
            margin-bottom: 35px;
            color: var(--primary-color);
            font-size: 1.6em;
            font-weight: 600;
        }

        .chart-grid {
            /* Thay th·∫ø div flex inline */
            display: grid;
            /* D√πng grid cho linh ho·∫°t */
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            /* T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh c·ªôt */
            gap: 40px;
            /* Kho·∫£ng c√°ch gi·ªØa c√°c bi·ªÉu ƒë·ªì */
            margin-bottom: 25px;
            /* Kho·∫£ng c√°ch tr∆∞·ªõc n√∫t c·∫≠p nh·∫≠t */
        }

        .chart-wrapper {
            background-color: #fdfdfd;
            padding: 20px;
            /* TƒÉng padding b√™n trong wrapper */
            border-radius: var(--border-radius-md);
            /* Bo g√≥c nhi·ªÅu h∆°n ch√∫t */
            border: 1px solid #eef2f5;
            /* Vi·ªÅn tinh t·∫ø h∆°n */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
            /* Th√™m shadow nh·∫π */
            /* ƒê·∫£m b·∫£o chi·ªÅu cao ƒë·ªß cho bi·ªÉu ƒë·ªì Top 3 v·ªõi nh√£n d√†i */
            min-height: 250px;
            /* ƒêi·ªÅu ch·ªânh n·∫øu c·∫ßn */
            display: flex;
            /* Gi√∫p canvas cƒÉn gi·ªØa n·∫øu c·∫ßn */
            flex-direction: column;
            /* S·∫Øp x·∫øp ti√™u ƒë·ªÅ v√† canvas */

        }

        /* CƒÉn ch·ªânh canvas b√™n trong wrapper (n·∫øu c·∫ßn) */
        .chart-wrapper canvas {
            max-width: 100%;
            /* ƒê·∫£m b·∫£o kh√¥ng tr√†n */
            /* C√≥ th·ªÉ kh√¥ng c·∫ßn set height ·ªü ƒë√¢y n·∫øu maintainAspectRatio: false */
        }

        /* N√∫t c·∫≠p nh·∫≠t bi·ªÉu ƒë·ªì */
        .chart-section .btn-primary {
            display: block;
            /* Chi·∫øm to√†n b·ªô chi·ªÅu r·ªông */
            width: fit-content;
            /* Ch·ªâ r·ªông b·∫±ng n·ªôi dung */
            margin: 20px auto 0;
            /* CƒÉn gi·ªØa v√† th√™m kho·∫£ng c√°ch tr√™n */
            padding: 12px 25px;
            /* TƒÉng padding cho n√∫t */
        }

        /* --- Logic ·∫®n/Hi·ªán C·ªôt --- */
        body.hide-id-column th.id-column,
        body.hide-id-column td.id-column {
            display: none;
        }

        body.hide-quaituan th.quai-tuan-column,
        body.hide-quaituan td.quai-tuan-column {
            display: none;
        }

        .countdown-group {
            min-width: 280px;
            /* ƒêi·ªÅu ch·ªânh ƒë·ªô r·ªông n·∫øu c·∫ßn */
        }

        #countdownDisplay {
            /* C√≥ th·ªÉ th√™m padding, font-size, etc. */
            font-size: 1.1em;
            min-height: 1.5em;
            /* ƒê·∫£m b·∫£o c√≥ kh√¥ng gian ngay c·∫£ khi tr·ªëng */
        }

        /* --- Responsive --- */

        /* M√†n h√¨nh nh·ªè h∆°n (Tablet d·ªçc & ƒêi·ªán tho·∫°i l·ªõn) */
        @media (max-width: 768px) {
            .main-container {
                padding: 0 15px;
                /* Gi·∫£m padding */
            }

            .header {
                flex-direction: column;
                align-items: stretch;
                /* C√°c item chi·∫øm ƒë·ªß chi·ªÅu r·ªông */
                padding: 15px;
            }

            .title-wrapper {
                text-align: center;
                /* CƒÉn gi·ªØa ti√™u ƒë·ªÅ */
            }

            .header-stat {
                margin-left: 0;
                margin-top: 15px;
            }

            .input-actions-group {
                justify-content: center;
                /* CƒÉn gi·ªØa c√°c control */
            }

            .input-group {
                max-width: none;
                /* Cho ph√©p input URL r·ªông h∆°n */
            }

            .toolbar {
                flex-direction: column;
                align-items: stretch;
                /* N√∫t chi·∫øm ƒë·ªß r·ªông */
                gap: 10px;
            }

            /* === TH√äM M·ªöI: Responsive cho √¥ t√¨m ki·∫øm === */
            .search-group {
                order: -1;
                /* ƒê∆∞a √¥ t√¨m ki·∫øm l√™n ƒë·∫ßu */
                width: 100%;
                margin-right: 0;
                margin-bottom: 5px;
                /* Th√™m kho·∫£ng c√°ch d∆∞·ªõi */
            }

            /* === K·∫æT TH√öC TH√äM M·ªöI === */
            .tab {
                margin-left: 0;
                /* B·ªè margin khi x·∫øp d·ªçc */
                width: 100%;
                justify-content: center;
                /* CƒÉn gi·ªØa c√°c n√∫t tab */
            }

            .tab button {
                flex-grow: 1;
                /* C√°c n√∫t tab chia ƒë·ªÅu kh√¥ng gian */
                text-align: center;
            }

            .btn {
                /* ƒê·∫£m b·∫£o c√°c n√∫t toolbar chi·∫øm ƒë·ªß r·ªông */
                width: 100%;
                box-sizing: border-box;
            }

            .download-btn {
                margin-top: 5px;
                /* Th√™m kho·∫£ng c√°ch nh·ªè */
            }

            .chart-grid {
                /* Grid t·ª± ƒë·ªông x·∫øp th√†nh 1 c·ªôt v√¨ minmax(250px, 1fr) */
                gap: 20px;
                /* Gi·∫£m gap */
            }

            .chart-section {
                padding: 20px;
                /* Gi·∫£m padding */
            }

            .countdown-group {
                width: 100%;
                /* Chi·∫øm ƒë·ªß r·ªông tr√™n mobile */
                max-width: none;
            }

            #countdownDisplay {
                text-align: center;
                /* CƒÉn gi·ªØa tr√™n mobile */
                margin-top: 15px;
            }
        }

        /* M√†n h√¨nh ƒëi·ªán tho·∫°i nh·ªè */
        @media (max-width: 480px) {
            .main-container {
                padding: 0 10px;
            }

            .header h1 {
                font-size: 1.6em;
                /* Gi·∫£m n·ªØa */
            }

            .btn {
                padding: 10px 15px;
                /* Gi·∫£m padding n√∫t */
                font-size: 13px;
            }

            .tab button {
                padding: 8px 10px;
            }

            th,
            td {
                padding: 8px 10px;
                /* Gi·∫£m padding cell */
                font-size: 13px;
                /* Gi·∫£m font ch·ªØ b·∫£ng */
            }

            .target-input {
                width: 55px;
                /* Gi·∫£m n·ªØa */
                font-size: 13px;
            }

            .chart-section h2 {
                font-size: 1.4em;
            }
        }

        /* --- Debt Checker Section --- */
        .debt-checker-section {
            margin-top: 30px;
            background: var(--white-color);
            border-radius: var(--border-radius-md);
            padding: 30px;
            box-shadow: var(--box-shadow-medium);
            border: 1px solid var(--light-gray);
        }

        .debt-checker-section h2 {
            text-align: center;
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--primary-color);
            font-size: 1.6em;
            font-weight: 600;
        }

        .debt-checker-section .description {
            text-align: center;
            max-width: 700px;
            margin: 0 auto 25px auto;
            color: var(--dark-gray);
            font-size: 14px;
        }

        .debt-checker-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 25px;
        }

        .debt-checker-controls textarea {
            width: 100%;
            max-width: 600px;
            min-height: 120px;
            padding: 12px;
            border: 1px solid var(--medium-gray);
            border-radius: var(--border-radius-md);
            font-family: Consolas, 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
        }

        .debt-checker-controls textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        #debtCheckResults {
            max-width: 800px;
            margin: 0 auto;
        }

        .debt-result-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid var(--light-gray);
            gap: 15px;
        }

        .debt-result-item:last-child {
            border-bottom: none;
        }

        .debt-result-info {
            flex-grow: 1;
        }

        .debt-result-info .name {
            font-weight: 600;
        }

        .debt-result-info .id {
            font-size: 12px;
            color: var(--dark-gray);
            margin-left: 5px;
        }

        .debt-result-status {
            font-weight: 700;
            white-space: nowrap;
        }

        .debt-status-in-debt {
            color: var(--danger-color);
        }

        .debt-status-sufficient {
            color: var(--success-color);
        }

        .debt-status-no-debt {
            color: var(--dark-gray);
        }

        .debt-status-not-found {
            color: var(--warning-color);
        }
    </style>
</head>

<body>

    <!-- Header gi·ªØ nguy√™n -->
    <div class="header">
        <div class="title-wrapper">
            <h1>üèπ Qu·∫£n L√Ω SƒÉn Qu√°i FvN</h1>
        </div>
        <!-- === TH√äM M·ªöI: Hi·ªÉn th·ªã t·ªïng ƒëi·ªÉm === -->
        <div class="header-stat">
            <span class="stat-label">T·ªïng ƒêi·ªÉm SƒÉn</span>
            <span id="totalPointsDisplay" class="stat-value">0</span>
        </div>
        <!-- === K·∫æT TH√öC TH√äM M·ªöI === -->
        <div class="input-actions-group">
            <div class="input-group">
                <input type="text" id="excelUrl" placeholder="D√°n link Google Sheets ho·∫∑c URL Excel..."
                    class="url-input">
                <!-- Th√™m class 'btn' v√† 'btn-primary' -->
                <button class="btn btn-primary" onclick="loadExcelFromUrl()">T·∫£i t·ª´ URL</button>
            </div>
            <div class="file-upload-controls">
                <div class="file-upload-group">
                    <label class="upload-label excel-label" for="excelFile">
                        Ch·ªçn file Excel
                        <span class="file-name" id="excelFileName"></span>
                    </label>
                    <input type="file" id="excelFile" accept=".xlsx, .xls"
                        onchange="document.getElementById('excelFileName').textContent = this.files[0]?.name || ''">
                </div>
                <div class="file-upload-group">
                    <label class="upload-label txt-label" for="txtFile">
                        Ch·ªçn file TXT
                        <span class="file-name" id="txtFileName"></span>
                    </label>
                    <input type="file" id="txtFile" accept=".txt"
                        onchange="document.getElementById('txtFileName').textContent = this.files[0]?.name || ''">
                </div>
                <!-- Th√™m class 'btn' v√† 'btn-primary' -->
                <button class="btn btn-primary process-txt-btn" onclick="processTxtFile()">X·ª≠ l√Ω TXT</button>
            </div>
            <!-- === TH√äM M·ªöI: Input ƒê·∫øm Ng∆∞·ª£c === -->
            <div class="input-group countdown-group">
                <input type="text" id="countdownInput" placeholder="nh·∫≠p times" class="url-input">
                <!-- T√°i s·ª≠ d·ª•ng class url-input -->
                <button class="btn btn-info" onclick="startCountdown()">T√≠nh Time Base</button> <!-- N√∫t m√†u kh√°c -->
            </div>
            <!-- === K·∫æT TH√öC TH√äM M·ªöI === -->
            <!-- === TH√äM M·ªöI: Hi·ªÉn th·ªã ƒê·∫øm Ng∆∞·ª£c === -->
            <div id="countdownDisplay"
                style="margin-top: 10px; font-weight: bold; color: var(--danger-color); text-align: right; width: 100%;">
                <!-- Th·ªùi gian ƒë·∫øm ng∆∞·ª£c s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y -->
            </div>
            <!-- === K·∫æT TH√öC TH√äM M·ªöI === -->
        </div>
    </div>

    <!-- B·ªçc n·ªôi dung ch√≠nh -->
    <div class="main-container">
        <div class="toolbar">
            <!-- === TH√äM M·ªöI: √î T√åM KI·∫æM === -->
            <div class="search-group">
                <input type="text" id="searchInput" placeholder="üîç T√¨m theo T√™n ho·∫∑c ID..." class="url-input"
                    oninput="filterCurrentTable()">
            </div>
            <!-- === K·∫æT TH√öC TH√äM M·ªöI === -->
            <!-- Th√™m class 'btn' v√† 'btn-toggle' -->
            <button class="btn btn-toggle" onclick="toggleQuaiTuan()">·∫®n/Hi·ªán Qu√°i Tu·∫ßn</button>
            <button class="btn btn-toggle" onclick="toggleIdColumn()">·∫®n/Hi·ªán ID</button>
            <!-- Th√™m class 'btn' v√† 'btn-export' -->
            <button class="btn btn-export export-image-btn" onclick="exportToImage()">üì∏ Xu·∫•t ·∫¢nh</button>
            <div class="tab">
                <!-- Th√™m class 'btn' cho c√°c n√∫t tab -->
                <button class="btn active" onclick="showTab('missing')">Thi·∫øu (<span
                        id="missingCount">0</span>)</button>
                <button class="btn" onclick="showTab('sufficient')">ƒê·ªß/D∆∞ (<span id="sufficientCount">0</span>)</button>
                <button class="btn" onclick="showTab('corrected')">ƒê√£ s·ª≠a (<span id="correctedCount">0</span>)</button>
            </div>
            <!-- N√∫t Xu·∫•t Excel s·∫Ω ƒë∆∞·ª£c th√™m b·∫±ng JS, c·∫ßn ƒë·∫£m b·∫£o n√≥ c≈©ng c√≥ class 'btn btn-success' -->
        </div>

        <!-- X√≥a style="display: none;" -->
        <div id="missing" class="tab-content">
            <div id="missingContent"></div>
        </div>
        <div id="sufficient" class="tab-content tab-content-hidden">
            <div id="sufficientContent"></div>
        </div>
        <div id="corrected" class="tab-content tab-content-hidden">
            <div id="correctedContent"></div>
        </div>

        <!-- X√≥a style inline, th√™m class 'chart-section' -->
        <div class="chart-section">
            <h2>üìä Th·ªëng K√™ Nhanh</h2>
            <!-- Th√™m class 'chart-grid' -->
            <div class="chart-grid">
                <!-- X√≥a style inline, th√™m class 'chart-wrapper' -->
                <div class="chart-wrapper">
                    <canvas id="statusChart"></canvas>
                </div>
                <div class="chart-wrapper">
                    <canvas id="topPlayersChart"></canvas>
                </div>
            </div>
            <!-- Th√™m class 'btn' v√† 'btn-primary' -->
            <button class="btn btn-primary" onclick="renderCharts()" style="margin-top: 15px;">T·∫°o/C·∫≠p nh·∫≠t Bi·ªÉu
                ƒê·ªì</button>
        </div>

        <!-- === TH√äM M·ªöI: Ph·∫ßn Ki·ªÉm Tra N·ª£ Qu√°i === -->
        <div class="debt-checker-section">
            <h2>üìù Ki·ªÉm Tra N·ª£ Qu√°i Tu·∫ßn Ti·∫øp Theo</h2>
            <p class="description">
                D√°n danh s√°ch ID v√†o √¥ b√™n d∆∞·ªõi ƒë·ªÉ ki·ªÉm tra
            </p>
            <div class="debt-checker-controls">
                <button class="btn btn-primary" onclick="runDebtCheck()">Ki·ªÉm Tra N·ª£</button>
                <label for="debtCheckFile" class="upload-label txt-label">Ch·ªçn file TXT</label>
                <input type="file" id="debtCheckFile" accept=".txt" onchange="document.getElementById('debtCheckFileName').textContent = this.files[0]?.name || 'Ch∆∞a ch·ªçn file'">
                <span class="file-name" id="debtCheckFileName">Ch∆∞a ch·ªçn file</span>
            </div>
            <div id="debtCheckResults">
            
                <!-- K·∫øt qu·∫£ s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã ·ªü ƒë√¢y -->
            </div>
        </div>
        <!-- === K·∫æT TH√öC TH√äM M·ªöI === -->
    </div>

    <script>
        // Khai b√°o bi·∫øn l∆∞u d·ªØ li·ªáu
        let statusChartInstance = null;
        let topPlayersChartInstance = null;
        let originalData = []; // Th√™m d√≤ng n√†y
        let processedData = [];
        let showQuaiTuan = false;
        let showIdColumn = false;
        let currentTab = 'missing';
        // === TH√äM M·ªöI: Bi·∫øn cho Countdown ===
        let countdownIntervalId = null;
        let countdownTargetTimestamp = null;
        // === K·∫æT TH√öC TH√äM M·ªöI ===        
        // X·ª≠ l√Ω hi·ªÉn th·ªã t√™n file
        document.getElementById('excelFile').addEventListener('change', function (e) {
            document.getElementById('excelFileName').textContent = this.files[0]?.name || 'Ch∆∞a ch·ªçn file';
        });

        document.getElementById('txtFile').addEventListener('change', function (e) {
            document.getElementById('txtFileName').textContent = this.files[0]?.name || 'Ch∆∞a ch·ªçn file';
        });
        // === K·∫æT TH√öC PH·∫¶N TH√äM ===

        document.getElementById('excelFile').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });

                    // C·∫≠p nh·∫≠t c·∫£ originalData v√† processedData
                    const searchInput = document.getElementById('searchInput');
                    if (searchInput) searchInput.value = '';


                    originalData = processData(jsonData); // D·ªØ li·ªáu g·ªëc
                    processedData = JSON.parse(JSON.stringify(originalData)); // B·∫£n sao ƒë·ªÉ ch·ªânh s·ª≠a
                    currentTab = 'missing';
                    updateUI();

                } catch (error) {
                    alert('L·ªói ƒë·ªçc file: ' + error.message);
                }
            };
            reader.readAsArrayBuffer(file);
        });

        // H√†m x·ª≠ l√Ω d·ªØ li·ªáu Excel g·ªëc
        function processExcelData(rawData) {
            const headers = rawData[0].map(h => h.trim().toLowerCase());

            return rawData.slice(1).map(row => {
                return {
                    id: parseInt(row[headers.indexOf("user id")]) || 0,
                    name: row[headers.indexOf("name")] || '',
                    levels: {
                        l1: parseInt(row[headers.indexOf("l1 (hunt)")]) || 0,
                        l2: parseInt(row[headers.indexOf("l2 (hunt)")]) || 0,
                        l3: parseInt(row[headers.indexOf("l3 (hunt)")]) || 0,
                        l4: parseInt(row[headers.indexOf("l4 (hunt)")]) || 0,
                        l5: parseInt(row[headers.indexOf("l5 (hunt)")]) || 0
                    },
                    target: 56, // Gi√° tr·ªã m·∫∑c ƒë·ªãnh
                    points: 0,
                    status: 'missing',
                    corrected: false
                };
            }).filter(item => item.id !== 0);
        }

        // H√†m x·ª≠ l√Ω file TXT
        function processTxtFile() {
            const txtFile = document.getElementById('txtFile').files[0];
            if (!txtFile) {
                alert("Vui l√≤ng ch·ªçn file TXT tr∆∞·ªõc.");
                return;
            }
            if (processedData.length === 0) {
                alert("Vui l√≤ng t·∫£i file Excel tr∆∞·ªõc khi x·ª≠ l√Ω file TXT.");
                return;
            }

            const reader = new FileReader();

            reader.onload = function (e) {
                const userIds = e.target.result.split(',').map(id => id.trim().replace(/\D/g, '')); // L·ªçc ch·ªâ gi·ªØ l·∫°i s·ªë
                let changesMade = 0;

                // Ch·ªâ c·∫≠p nh·∫≠t processedData, gi·ªØ nguy√™n originalData
                userIds.forEach(uid => {
                    if (!uid) return; // B·ªè qua c√°c chu·ªói r·ªóng sau khi l·ªçc
                    const user = processedData.find(item => String(item.id) === uid);
                    if (user) {
                        // N·∫øu ƒëi·ªÉm hi·ªán t·∫°i c·ªßa ng∆∞·ªùi ch∆°i th·∫•p h∆°n m·ª•c ti√™u
                        if (user.points < user.target) {
                            // C·∫≠p nh·∫≠t m·ª•c ti√™u m·ªõi b·∫±ng ch√≠nh ƒëi·ªÉm h·ªç sƒÉn ƒë∆∞·ª£c
                            user.target = user.points;
                            // ƒê√°nh d·∫•u l√† ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω qua file TXT
                            user.corrected = true;
                            // C·∫≠p nh·∫≠t l·∫°i tr·∫°ng th√°i c·ªßa ng∆∞·ªùi ch∆°i (s·∫Ω th√†nh 'sufficient')
                            updateStatus(user);
                            changesMade++;
                        }
                        // N·∫øu ƒëi·ªÉm >= m·ª•c ti√™u, kh√¥ng l√†m g√¨ c·∫£ theo y√™u c·∫ßu.
                    }
                });

                if (changesMade > 0) {
                    alert(`ƒê√£ c·∫≠p nh·∫≠t m·ª•c ti√™u cho ${changesMade} th√†nh vi√™n.`);
                    updateUI();
                } else {
                    alert("Kh√¥ng c√≥ th√†nh vi√™n n√†o trong file TXT c·∫ßn c·∫≠p nh·∫≠t (t·∫•t c·∫£ ƒë·ªÅu ƒë√£ ƒë·ªß/d∆∞ ƒëi·ªÉm ho·∫∑c kh√¥ng t√¨m th·∫•y).");
                }
            };
            reader.readAsText(txtFile);
        }

        /* ‚ñº‚ñº‚ñº Th√™m h√†m xu·∫•t ·∫£nh ·ªü ƒë√¢y ‚ñº‚ñº‚ñº */
        async function exportToImage() {
            if (!processedData.length) {
                alert("Vui l√≤ng t·∫£i file Excel tr∆∞·ªõc!");
                return;
            }

            const contentDivId = `${currentTab}Content`;
            const contentDiv = document.getElementById(contentDivId);

            if (!contentDiv) {
                alert("Kh√¥ng t√¨m th·∫•y n·ªôi dung ƒë·ªÉ ch·ª•p ·∫£nh.");
                return;
            }

            // T√¨m ch√≠nh x√°c th·∫ª table b√™n trong div responsive
            const tableElement = contentDiv.querySelector('.table-responsive > table');

            if (!tableElement) {
                alert(`Kh√¥ng t√¨m th·∫•y b·∫£ng d·ªØ li·ªáu trong tab "${currentTab}" ƒë·ªÉ xu·∫•t ·∫£nh.`);
                return;
            }

            // --- Chu·∫©n b·ªã ch·ª•p: T·∫°m th·ªùi s·ª≠a style ---
            const thElements = tableElement.querySelectorAll('th');
            const originalThStyles = [];
            thElements.forEach(th => {
                originalThStyles.push(th.style.position); // L∆∞u style g·ªëc
                th.style.position = 'static'; // T·∫°m th·ªùi b·ªè sticky
            });
            // C√≥ th·ªÉ c·∫ßn t·∫°m th·ªùi b·ªè overflow tr√™n container n·∫øu v·∫´n l·ªói
            // const responsiveDiv = contentDiv.querySelector('.table-responsive');
            // const originalOverflow = responsiveDiv.style.overflowX;
            // responsiveDiv.style.overflowX = 'visible';


            // --- Ph·∫£n h·ªìi UI ---
            const exportButton = document.querySelector('.export-image-btn');
            const originalButtonText = exportButton.textContent;
            exportButton.textContent = 'üì∏ ƒêang x·ª≠ l√Ω...';
            exportButton.disabled = true;

            // --- Tr√¨ ho√£n v√† Ch·ª•p ---
            setTimeout(async () => {
                let stylesRestored = false;
                const restoreStyles = () => {
                    if (!stylesRestored) {
                        thElements.forEach((th, index) => {
                            th.style.position = originalThStyles[index] || ''; // Kh√¥i ph·ª•c style g·ªëc
                        });
                        // if (responsiveDiv) responsiveDiv.style.overflowX = originalOverflow; // Kh√¥i ph·ª•c overflow
                        stylesRestored = true;
                        console.log("ƒê√£ kh√¥i ph·ª•c style.");
                    }
                };

                try {
                    console.log("B·∫Øt ƒë·∫ßu ch·ª•p ·∫£nh b·∫£ng:", tableElement);
                    console.log("K√≠ch th∆∞·ªõc ch·ª•p (scrollWidth x scrollHeight):", tableElement.scrollWidth, tableElement.scrollHeight);

                    const canvas = await html2canvas(tableElement, { // Ch·ª•p tr·ª±c ti·∫øp tableElement
                        scale: 1.5,
                        useCORS: true,
                        logging: false,
                        backgroundColor: '#ffffff',
                        // --- THAY ƒê·ªîI QUAN TR·ªåNG ---
                        width: tableElement.scrollWidth,   // ƒê·∫∑t chi·ªÅu r·ªông canvas b·∫±ng chi·ªÅu r·ªông n·ªôi dung th·ª±c t·∫ø c·ªßa b·∫£ng
                        height: tableElement.scrollHeight, // ƒê·∫∑t chi·ªÅu cao canvas b·∫±ng chi·ªÅu cao n·ªôi dung th·ª±c t·∫ø c·ªßa b·∫£ng
                        // B·ªè scrollX/Y v√† windowWidth/Height
                        // scrollX: 0,
                        // scrollY: 0, // Kh√¥ng c·∫ßn scrollY v√¨ ch·ª•p tr·ª±c ti·∫øp table
                        // windowWidth: tableElement.scrollWidth, // D√πng width thay th·∫ø
                        // windowHeight: tableElement.scrollHeight // D√πng height thay th·∫ø
                        // --- K·∫æT TH√öC THAY ƒê·ªîI ---
                    });
                    console.log("ƒê√£ t·∫°o canvas");

                    restoreStyles(); // Kh√¥i ph·ª•c style ngay

                    const imageDataUrl = canvas.toDataURL('image/png');
                    console.log("ImageDataUrl (ƒë·∫ßu):", imageDataUrl.substring(0, 100));

                    // --- M·ªü ·∫£nh trong tab m·ªõi ---
                    const newWindow = window.open();
                    if (newWindow) {
                        newWindow.document.write(`
                    <!DOCTYPE html>
                    <html>
                        <head><title>B√°o c√°o ${currentTab}</title></head>
                        <body style="margin:0;">
                            <img src="${imageDataUrl}" alt="B√°o c√°o ${currentTab}" style="max-width: 100%; display: block;">
                        </body>
                    </html>`);
                        newWindow.document.close();
                    } else {
                        alert("Kh√¥ng th·ªÉ m·ªü tab m·ªõi. Vui l√≤ng ki·ªÉm tra c√†i ƒë·∫∑t ch·∫∑n pop-up c·ªßa tr√¨nh duy·ªát v√† th·ª≠ l·∫°i.");
                    }

                } catch (error) {
                    console.error('L·ªói xu·∫•t ·∫£nh:', error);
                    alert(`Xu·∫•t ·∫£nh th·∫•t b·∫°i! L·ªói: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c ki·ªÉm tra console.`);
                    restoreStyles(); // ƒê·∫£m b·∫£o kh√¥i ph·ª•c n·∫øu l·ªói
                } finally {
                    // --- Kh√¥i ph·ª•c n√∫t ---
                    exportButton.textContent = originalButtonText;
                    exportButton.disabled = false;
                    console.log("Ho√†n t·∫•t x·ª≠ l√Ω xu·∫•t ·∫£nh.");
                }
            }, 150); // Gi·ªØ nguy√™n ƒë·ªô tr·ªÖ
        }



        /* ‚ñ≤‚ñ≤‚ñ≤ K·∫øt th√∫c ph·∫ßn th√™m h√†m ‚ñ≤‚ñ≤‚ñ≤ */

        function processData(data) {
            const result = [];
            if (data.length < 2) return result;

            const headers = data[0].map(h => h.trim().toLowerCase());
            const colIndex = {
                userId: headers.indexOf("user id"),
                name: headers.indexOf("name"),
                l1: headers.indexOf("l1 (hunt)"),
                l2: headers.indexOf("l2 (hunt)"),
                l3: headers.indexOf("l3 (hunt)"),
                l4: headers.indexOf("l4 (hunt)"),
                l5: headers.indexOf("l5 (hunt)")
            };

            for (let i = 1; i < data.length; i++) {
                const row = data[i];
                if (!row || row.length === 0) continue;

                const item = {
                    id: parseInt(row[colIndex.userId]) || 0,
                    name: row[colIndex.name] || '',
                    levels: {
                        l1: parseInt(row[colIndex.l1]) || 0,
                        l2: parseInt(row[colIndex.l2]) || 0,
                        l3: parseInt(row[colIndex.l3]) || 0,
                        l4: parseInt(row[colIndex.l4]) || 0,
                        l5: parseInt(row[colIndex.l5]) || 0
                    },
                    target: 56,
                    status: 'missing'
                };

                calculatePoints(item);
                result.push(item);
            }

            return result.filter(item => item.id !== 0);
        }

        function calculatePoints(item) {
            item.points = item.levels.l2 +
                (item.levels.l3 * 4) +
                (item.levels.l4 * 16) +
                (item.levels.l5 * 32);
            updateStatus(item);
        }

        function updateStatus(item) {
            const diff = item.points - item.target;
            item.status = diff >= 0 ? (diff > 0 ? 'excess' : 'sufficient') : 'missing';
        }
        function renderCharts() {
            if (!processedData || processedData.length === 0) {
                alert("Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ v·∫Ω bi·ªÉu ƒë·ªì. Vui l√≤ng t·∫£i file Excel tr∆∞·ªõc.");
                return;
            }

            // --- D·ªØ li·ªáu cho Bi·ªÉu ƒë·ªì Tr·∫°ng th√°i (Pie Chart) ---
            const statusCounts = {
                missing: processedData.filter(item => item.status === 'missing').length,
                sufficient: processedData.filter(item => item.status === 'sufficient').length,
                excess: processedData.filter(item => item.status === 'excess').length,
            };

            const statusCtx = document.getElementById('statusChart').getContext('2d');

            // H·ªßy bi·ªÉu ƒë·ªì c≈© n·∫øu t·ªìn t·∫°i
            if (statusChartInstance) {
                statusChartInstance.destroy();
            }

            statusChartInstance = new Chart(statusCtx, {
                type: 'doughnut', // Ho·∫∑c 'pie'
                data: {
                    labels: ['Thi·∫øu', 'ƒê·ªß', 'D∆∞'],
                    datasets: [{
                        label: 'Ph√¢n lo·∫°i tr·∫°ng th√°i',
                        data: [statusCounts.missing, statusCounts.sufficient, statusCounts.excess],
                        backgroundColor: [
                            'rgb(241, 196, 15)', // Warning color (Thi·∫øu)
                            'rgb(46, 204, 113)', // Success color (ƒê·ªß)
                            'rgb(231, 76, 60)'   // Danger color (D∆∞)
                        ],
                        hoverOffset: 4
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'T·ª∑ l·ªá tr·∫°ng th√°i sƒÉn qu√°i'
                        }
                    }
                }
            });

            // --- D·ªØ li·ªáu cho Bi·ªÉu ƒë·ªì Top Ng∆∞·ªùi Ch∆°i (Bar Chart) ---
            const topN = 3; // L·∫•y top 3 ng∆∞·ªùi
            const sortedPlayers = [...processedData]
                .sort((a, b) => b.points - a.points)
                .slice(0, topN);

            const topPlayersCtx = document.getElementById('topPlayersChart').getContext('2d');

            // H·ªßy bi·ªÉu ƒë·ªì c≈© n·∫øu t·ªìn t·∫°i
            if (topPlayersChartInstance) {
                topPlayersChartInstance.destroy();
            }

            topPlayersChartInstance = new Chart(topPlayersCtx, {
                type: 'bar',
                data: {
                    labels: sortedPlayers.map((p, index) => {
                        const rank = index + 1;
                        const shortName = p.name.substring(0, 15) + (p.name.length > 15 ? '...' : ''); // Gi·ªØ l·∫°i vi·ªác c·∫Øt ng·∫Øn t√™n
                        return `Top ${rank}: ${shortName} (${p.points} ƒëi·ªÉm)`; // T·∫°o label m·ªõi
                    }),
                    // ‚ñ≤‚ñ≤‚ñ≤ K·∫æT TH√öC THAY ƒê·ªîI ‚ñ≤‚ñ≤‚ñ≤
                    datasets: [{
                        label: `Top ${topN} mem sƒÉn nhi·ªÅu nh·∫•t`,
                        data: sortedPlayers.map(p => p.points),
                        backgroundColor: 'rgba(52, 152, 219, 0.7)', // Primary color with transparency
                        borderColor: 'rgb(52, 152, 219)',
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y', // Hi·ªÉn th·ªã thanh ngang ƒë·ªÉ d·ªÖ ƒë·ªçc t√™n
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            beginAtZero: true
                        }
                    },
                    y: {
                        ticks: {
                            autoSkip: false // ƒê·∫£m b·∫£o t·∫•t c·∫£ nh√£n ƒë·ªÅu hi·ªÉn th·ªã
                        },
                        afterFit: function (scaleInstance) {
                            scaleInstance.width = 200; // TƒÉng chi·ªÅu r·ªông khu v·ª±c nh√£n tr·ª•c Y (ƒëi·ªÅu ch·ªânh n·∫øu c·∫ßn)
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Top ${topN} mem sƒÉn nhi·ªÅu nh·∫•t`,
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        legend: {
                            display: false // C√≥ th·ªÉ ·∫©n ch√∫ th√≠ch n·∫øu ch·ªâ c√≥ 1 dataset
                        },
                        tooltip: { // C√≥ th·ªÉ t√πy ch·ªânh tooltip n·∫øu mu·ªën
                            callbacks: {
                                label: function (context) {
                                    // Ch·ªâ hi·ªÉn th·ªã gi√° tr·ªã ƒëi·ªÉm trong tooltip v√¨ t√™n ƒë√£ c√≥ tr√™n tr·ª•c Y
                                    return `ƒêi·ªÉm: ${context.parsed.x}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateUI() {
            updateTotalPointsDisplay(); // C·∫≠p nh·∫≠t t·ªïng ƒëi·ªÉm
            updateCounts(); // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng c√°c tab
            renderTable(currentTab);

            // Ch·ªâ x√≥a n√∫t Excel (class 'download-btn')
            document.querySelector('.download-btn')?.remove();

            createDownloadButton(); // T·∫°o l·∫°i n√∫t Excel m·ªõi

            // G·ªçi h√†m v·∫Ω bi·ªÉu ƒë·ªì (n·∫øu c√≥ d·ªØ li·ªáu)
            if (processedData && processedData.length > 0) {
                // C√≥ th·ªÉ th√™m ƒë·ªô tr·ªÖ nh·ªè ƒë·ªÉ ƒë·∫£m b·∫£o DOM c·∫≠p nh·∫≠t xong
                // setTimeout(renderCharts, 100);
                // Ho·∫∑c g·ªçi tr·ª±c ti·∫øp n·∫øu kh√¥ng g·∫∑p v·∫•n ƒë·ªÅ
                renderCharts();
            }
        }

        // === TH√äM M·ªöI: H√†m c·∫≠p nh·∫≠t t·ªïng ƒëi·ªÉm ===
        function updateTotalPointsDisplay() {
            const totalPoints = processedData.reduce((sum, item) => sum + item.points, 0);
            const displayElement = document.getElementById('totalPointsDisplay');
            if (displayElement) {
                // ƒê·ªãnh d·∫°ng s·ªë cho d·ªÖ ƒë·ªçc (vd: 1.234.567)
                displayElement.textContent = totalPoints.toLocaleString('vi-VN');
            }
        }
        // === K·∫æT TH√öC TH√äM M·ªöI ===


        function updateCounts() {
            const counts = {
                missing: processedData.filter(item => item.status === 'missing').length,
                sufficient: processedData.filter(item => item.status === 'sufficient').length,
                excess: processedData.filter(item => item.status === 'excess').length,
                corrected: processedData.filter(item => item.corrected).length
            };

            document.getElementById('missingCount').textContent = counts.missing;
            document.getElementById('sufficientCount').textContent = counts.sufficient + counts.excess;
            document.getElementById('correctedCount').textContent = counts.corrected;
        }

        // C·∫≠p nh·∫≠t h√†m render cho tab "ƒê√£ s·ª≠a"
        // Trong h√†m renderTable, x√≥a logic x·ª≠ l√Ω tab Top 3
        function filterCurrentTable() {
            // Ch·ªâ c·∫ßn render l·∫°i tab hi·ªán t·∫°i, logic l·ªçc ƒë√£ ƒë∆∞·ª£c t√≠ch h·ª£p v√†o renderTable
            renderTable(currentTab);
        }

        function renderTable(tabId) {
            const searchInput = document.getElementById('searchInput');
            const searchTerm = searchInput ? searchInput.value.trim().toLowerCase() : '';

            let dataToRender = [];
            let originalDataForTab = []; // D·ªØ li·ªáu g·ªëc cho tab hi·ªán t·∫°i

            switch (tabId) {
                case 'missing':
                    originalDataForTab = processedData.filter(item => item.status === 'missing');
                    break;
                case 'sufficient':
                    originalDataForTab = [...processedData]
                        .filter(item => item.status !== 'missing')
                        .sort((a, b) => b.points - a.points);
                    break;
                case 'corrected':
                    if (!originalData || originalData.length === 0) {
                        originalDataForTab = [];
                    } else {
                        const correctedIds = processedData.filter(item => item.corrected).map(item => item.id);
                        originalDataForTab = originalData.filter(item => correctedIds.includes(item.id));
                    }
                    break;
            }

            // √Åp d·ª•ng b·ªô l·ªçc t√¨m ki·∫øm n·∫øu c√≥
            if (searchTerm) {
                dataToRender = originalDataForTab.filter(item => {
                    const nameMatch = item.name.toLowerCase().includes(searchTerm);
                    const idMatch = String(item.id).includes(searchTerm);
                    return nameMatch || idMatch;
                });
            } else {
                dataToRender = originalDataForTab;
            }

            document.getElementById(`${tabId}Content`).innerHTML = generateTable(dataToRender, tabId);

        }

        // S·ª≠a l·∫°i h√†m generateTable ch·ªâ d√πng cho c√°c tab th∆∞·ªùng
        function generateTable(data, tabId) {
            if (!data || data.length === 0) return '<p class="empty">Kh√¥ng c√≥ d·ªØ li·ªáu</p>';
        
            const showCheckbox = tabId === 'missing';

            // --- B·∫Øt ƒë·∫ßu: T√≠nh to√°n cho d√≤ng t·ªïng k·∫øt ---
            let footerHtml = '';
            if (tabId === 'sufficient' || tabId === 'corrected') {
                const totals = data.reduce((acc, item) => {
                    acc.l1 += item.levels.l1;
                    acc.l2 += item.levels.l2;
                    acc.l3 += item.levels.l3;
                    acc.l4 += item.levels.l4;
                    acc.l5 += item.levels.l5;
                    acc.points += item.points;
                    if (tabId === 'corrected') {
                        const missing = item.target - item.points;
                        if (missing > 0) {
                            acc.thieu += missing;
                            acc.bu += missing + 5;
                        }
                    }
                    return acc;
                }, { l1: 0, l2: 0, l3: 0, l4: 0, l5: 0, points: 0, thieu: 0, bu: 0 });

                const format = (num) => num.toLocaleString('vi-VN');

                footerHtml = `
                    <tfoot>
                        <tr class="table-summary-row">
                            <td class="id-column"></td> <!-- C·ªôt ID ƒë·ªÉ tr·ªëng -->
                            <td><strong>T·ªïng c·ªông</strong></td> <!-- Ch·ªØ 'T·ªïng c·ªông' ·ªü c·ªôt T√™n -->
                            <td>${format(totals.l1)}</td>
                            <td>${format(totals.l2)}</td>
                            <td>${format(totals.l3)}</td>
                            <td>${format(totals.l4)}</td>
                            <td>${format(totals.l5)}</td>
                            <td class="quai-tuan-column"></td>
                            <td>${format(totals.points)}</td>
                            <td>${tabId === 'corrected' ? format(totals.thieu) : ''}</td>
                            ${tabId === 'corrected' ? `<td>${format(totals.bu)}</td>` : ''}
                        </tr>
                    </tfoot>
                `;
            }
            // --- K·∫øt th√∫c: T√≠nh to√°n cho d√≤ng t·ªïng k·∫øt ---
        
            // B·ªçc b·∫£ng trong div.table-responsive
            return `
            <div class="table-responsive"><table>
                    <thead>
                        <tr>
                            ${showCheckbox ? '<th></th>' : ''}
                            <th class="id-column">ID</th>
                            <th>T√™n</th>
                            <th>1</th>
                            <th>2</th>
                            <th>3</th>
                            <th>4</th>
                            <th>5</th>
                            <th class="quai-tuan-column">Qu√°i Tu·∫ßn</th>
                            <th>Points Hunt</th>
                            <th>${tabId === 'sufficient' ? 'D∆∞' : 'Thi·∫øu'}</th>
                            ${tabId !== 'sufficient' ? '<th>B√π</th>' : ''}
                        </tr>
                    </thead>
                    <tbody>
                        ${data.map(item => `
                            <tr>
                                ${showCheckbox ? `
                                    <td><input type="checkbox" data-id="${item.id}"></td>
                                ` : ''}
                                <td class="id-column">${item.id}</td>
                                <td>${item.name}</td>
                                <td>${item.levels.l1}</td>
                                <td>${item.levels.l2}</td>
                                <td>${item.levels.l3}</td>
                                <td>${item.levels.l4}</td>
                                <td>${item.levels.l5}</td>
                                <td class="quai-tuan-column">
                                    <input type="number"
                                           value="${item.target}"
                                           data-id="${item.id}"
                                           class="target-input">
                                </td>
                                <td>${item.points}</td>
                                <td>${tabId === 'sufficient' ?
                    Math.max(item.points - item.target, 0) :
                    item.target - item.points}
                                </td>
                                ${tabId !== 'sufficient' ? `
                                    <td>${(item.target - item.points) + 5}</td>
                                ` : ''}
                            </tr>
                        `).join('')}
                    </tbody>
                    ${footerHtml}
                </table>
            </div><br>
            ${showCheckbox ? `
                <div class="table-footer">
                    <button onclick="processCorrections()">C·∫≠p nh·∫≠t m·ª•c ch·ªçn</button>
                </div>
            ` : ''}
            ${tabId === 'missing' && data.length > 0 ? `
                <div class="table-footer">
                    <button onclick="exportMissingIdsToTxt()">Xu·∫•t ID Thi·∫øu</button>
                </div>
            ` : ''}
        `;
        }

        
        function getStatusText(item) {
            const diff = item.points - item.target;
            if (diff < 0) return `Thi·∫øu ${-diff}`;
            if (diff === 0) return 'ƒê·ªß';
            return `D∆∞ ${diff}`;
        }



        // Th√™m h√†m t√≠nh level cao nh·∫•t
        function calculateHighestLevel(levels) {
            const levelValues = [levels.l2, levels.l3, levels.l4, levels.l5];
            let maxLevel = 2;
            levelValues.forEach((val, idx) => {
                if (val > 0) maxLevel = idx + 2;
            });
            return maxLevel;
        }

        // C·∫≠p nh·∫≠t h√†m showTab ƒë·ªÉ d√πng class thay v√¨ style inline
        function showTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(el => {
                el.classList.add('tab-content-hidden'); // Th√™m class ·∫©n
                el.style.display = 'none'; // V·∫´n gi·ªØ display none ƒë·ªÉ ƒë·∫£m b·∫£o ·∫©n ban ƒë·∫ßu
            });
            const activeTabContent = document.getElementById(tabId);
            activeTabContent.classList.remove('tab-content-hidden'); // X√≥a class ·∫©n
            activeTabContent.style.display = 'block'; // Hi·ªÉn th·ªã

            // C·∫≠p nh·∫≠t class 'active' cho n√∫t tab
            document.querySelectorAll('.tab button').forEach(btn => btn.classList.remove('active'));
            // T√¨m n√∫t t∆∞∆°ng ·ª©ng v√† th√™m class active (c·∫ßn ƒë·∫£m b·∫£o onclick c√≥ c√°ch l·∫•y ƒë√∫ng n√∫t)
            // V√≠ d·ª• ƒë∆°n gi·∫£n: t√¨m theo n·ªôi dung text ho·∫∑c th√™m data-tab attribute
            document.querySelector(`.tab button[onclick="showTab('${tabId}')"]`).classList.add('active');


            currentTab = tabId;
            renderTable(tabId);
        }

        function toggleQuaiTuan() {
            showQuaiTuan = !showQuaiTuan;
            // Th√™m/x√≥a class 'hide-quaituan' tr√™n th·∫ª body
            document.body.classList.toggle('hide-quaituan', !showQuaiTuan);
            // Kh√¥ng c·∫ßn render l·∫°i b·∫£ng
        }

        function toggleIdColumn() {
            showIdColumn = !showIdColumn;
            // Th√™m/x√≥a class 'hide-id-column' tr√™n th·∫ª body
            document.body.classList.toggle('hide-id-column', !showIdColumn);
            // Kh√¥ng c·∫ßn render l·∫°i b·∫£ng v√¨ CSS s·∫Ω x·ª≠ l√Ω vi·ªác ·∫©n/hi·ªán
        }

        // H√†m x·ª≠ l√Ω c·∫≠p nh·∫≠t m·ª•c ch·ªçn
        function processCorrections() {
            const selectedIds = Array.from(document.querySelectorAll('input[type="checkbox"]:checked'))
                .map(checkbox => parseInt(checkbox.dataset.id));
            
            if (selectedIds.length === 0) {
                alert("Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt th√†nh vi√™n ƒë·ªÉ c·∫≠p nh·∫≠t.");
                return;
            }

            let changesMade = 0;
            processedData.forEach(item => {
                if (selectedIds.includes(item.id)) {
                    // Ch·ªâ c·∫≠p nh·∫≠t n·∫øu ng∆∞·ªùi ch∆°i ƒëang thi·∫øu ƒëi·ªÉm
                    if (item.points < item.target) {
                        item.target = item.points; // C·∫≠p nh·∫≠t m·ª•c ti√™u ('Qu√°i Tu·∫ßn') b·∫±ng ƒëi·ªÉm hi·ªán t·∫°i ('Points Hunt')
                        item.corrected = true;     // ƒê√°nh d·∫•u l√† ƒë√£ s·ª≠a
                        updateStatus(item);        // C·∫≠p nh·∫≠t l·∫°i tr·∫°ng th√°i (s·∫Ω th√†nh 'sufficient')
                        changesMade++;
                    }
                }
            });

            if (changesMade > 0) {
                alert(`ƒê√£ c·∫≠p nh·∫≠t m·ª•c ti√™u cho ${changesMade} th√†nh vi√™n ƒë∆∞·ª£c ch·ªçn.`);
            } else {
                alert("Kh√¥ng c√≥ th√†nh vi√™n n√†o ƒë∆∞·ª£c ch·ªçn c·∫ßn c·∫≠p nh·∫≠t (t·∫•t c·∫£ ƒë·ªÅu ƒë√£ ƒë·ªß/d∆∞ ƒëi·ªÉm).");
            }
            updateUI();
        }

        // C·∫≠p nh·∫≠t h√†m createDownloadButton ƒë·ªÉ th√™m class
        function createDownloadButton() {
            // X√≥a n√∫t c≈© tr∆∞·ªõc khi t·∫°o m·ªõi (ƒë·ªÉ tr√°nh tr√πng l·∫∑p)
            document.querySelector('.download-btn')?.remove();

            const btn = document.createElement('button');
            // Th√™m c√°c class c·∫ßn thi·∫øt
            btn.className = 'btn btn-success download-btn'; // Class chung v√† class ri√™ng
            btn.textContent = 'üì• Xu·∫•t Excel';
            btn.onclick = exportToExcel;
            document.querySelector('.toolbar').appendChild(btn);
        }
        // G·ªçi showTab ban ƒë·∫ßu ƒë·ªÉ ·∫©n c√°c tab kh√¥ng active
        document.addEventListener('DOMContentLoaded', () => {
            // Th√™m class ƒë·ªÉ ·∫©n c·ªôt ID v√† Qu√°i Tu·∫ßn m·∫∑c ƒë·ªãnh
            document.body.classList.add('hide-id-column');
            document.body.classList.add('hide-quaituan');
            showTab('missing'); // Hi·ªÉn th·ªã tab m·∫∑c ƒë·ªãnh
        });
        function exportToExcel() {
    try {
        const wb = XLSX.utils.book_new();
        const cleanSheetName = (name) => name.replace(/[\/:*?[\]]/g, '-');

        // S·∫Øp x·∫øp d·ªØ li·ªáu: "Thi·∫øu" l√™n ƒë·∫ßu, sau ƒë√≥ theo ƒëi·ªÉm gi·∫£m d·∫ßn
        const sortedData = [...processedData].sort((a, b) => {
            const aIsMissing = a.status === 'missing';
            const bIsMissing = b.status === 'missing';

            if (aIsMissing && !bIsMissing) return -1; // a (thi·∫øu) l√™n tr∆∞·ªõc b (kh√¥ng thi·∫øu)
            if (!aIsMissing && bIsMissing) return 1;  // b (thi·∫øu) l√™n tr∆∞·ªõc a (kh√¥ng thi·∫øu)

            // N·∫øu c·∫£ hai c√πng tr·∫°ng th√°i (c√πng thi·∫øu ho·∫∑c c√πng kh√¥ng), s·∫Øp x·∫øp theo ƒëi·ªÉm gi·∫£m d·∫ßn
            return b.points - a.points;
        });

        // Chu·∫©n b·ªã d·ªØ li·ªáu ƒë·ªÉ xu·∫•t t·ª´ d·ªØ li·ªáu ƒë√£ s·∫Øp x·∫øp
        const wsData = [
            ["User ID", "Name", "L1 (Hunt)", "L2 (Hunt)", "L3 (Hunt)", "L4 (Hunt)", "L5 (Hunt)", "Points Hunt", "Qu√°i Tu·∫ßn", "Thi·∫øu", "B√π"],
            ...sortedData.map(item => [
                item.id,
                item.name,
                item.levels.l1,
                item.levels.l2,
                item.levels.l3,
                item.levels.l4,
                item.levels.l5,
                item.points,
                item.target,
                item.points === item.target ? "ƒê·ªß" : 
                    item.points < item.target ? `Thi·∫øu ${item.target - item.points}` : `D∆∞ ${item.points - item.target}`,
                item.points < item.target ? `B√π ${(item.target - item.points) + 5}` : 0
            ])
        ];

        // Create worksheet
        const ws = XLSX.utils.aoa_to_sheet(wsData);

        // Add column formatting
        ws['!cols'] = [
            { wch: 10 }, // User ID
            { wch: 25 }, // Name
            { wch: 8 },  // L1
            { wch: 8 },  // L2
            { wch: 8 },  // L3
            { wch: 8 },  // L4
            { wch: 8 },  // L5
            { wch: 12 }, // Points Hunt
            { wch: 12 }, // Qu√°i Tu·∫ßn
            { wch: 15 }, // Thi·∫øu
            { wch: 10 }  // B√π
        ];

        // Add conditional formatting for "Thi·∫øu" (yellow) and "B√π" (orange)
        // Note: This requires using XLSX.utils.sheet_add_json with cell styling options
        // or creating a separate XLSX file with styling (more complex)
        
        // Alternative approach: Create HTML table with styling and convert to Excel
        // This will preserve basic colors but may not be perfect
        
        // For better formatting, we can use the xlsx-style library (not included by default)
        // Here's a simpler approach that will work with basic Excel export:
        
        // Mark cells that need styling (will be processed by Excel)
        wsData.forEach((row, rowIndex) => {
            if (rowIndex === 0) return; // Skip header
            
            // Column J (Thi·∫øu) - index 9
            const thi·∫øuCell = XLSX.utils.encode_cell({r: rowIndex, c: 9});
            if (ws[thi·∫øuCell] && ws[thi·∫øuCell].v.includes("Thi·∫øu")) {
                ws[thi·∫øuCell].s = { fill: { fgColor: { rgb: "FFFFFF00" } } }; // Yellow
            }
            
            // Column K (B√π) - index 10
            const b√πCell = XLSX.utils.encode_cell({r: rowIndex, c: 10});
            if (ws[b√πCell] && typeof ws[b√πCell].v === 'string' && ws[b√πCell].v.startsWith("B√π")) {
                ws[b√πCell].s = { fill: { fgColor: { rgb: "FFFFA500" } } }; // M√†u cam
            }
        });

        // Th√™m c√¥ng th·ª©c d·ª±a tr√™n d·ªØ li·ªáu ƒë√£ s·∫Øp x·∫øp
        sortedData.forEach((item, index) => {
            const rowNum = index + 2; // 1-based index, row 1 is header
            
            // Points Hunt formula (column H)
            const pointsCell = XLSX.utils.encode_cell({r: rowNum-1, c: 7});
            ws[pointsCell] = { 
                f: `D${rowNum}+(E${rowNum}*4)+(F${rowNum}*16)+(G${rowNum}*32)`,
                v: item.points 
            };
            
            // Thi·∫øu formula (column J)
            const thieuCell = XLSX.utils.encode_cell({r: rowNum-1, c: 9});
            ws[thieuCell] = { 
                f: `IF(H${rowNum}=I${rowNum}, "ƒê·ªß", IF(H${rowNum}<I${rowNum}, "Thi·∫øu "&(I${rowNum}-H${rowNum}), "D∆∞ "&(H${rowNum}-I${rowNum})))`,
                v: item.points === item.target ? "ƒê·ªß" : 
                    item.points < item.target ? `Thi·∫øu ${item.target - item.points}` : `D∆∞ ${item.points - item.target}`
            };
            
            // B√π formula (column K)
            const buCell = XLSX.utils.encode_cell({r: rowNum-1, c: 10});
            ws[buCell] = { 
                f: `IF(ISNUMBER(SEARCH("Thi·∫øu",J${rowNum})), "B√π " & (I${rowNum}-H${rowNum}+5), 0)`,
                v: item.points < item.target ? `B√π ${(item.target - item.points) + 5}` : 0
            };
        });

        // Add worksheet to workbook
        XLSX.utils.book_append_sheet(wb, ws, cleanSheetName("B√°o c√°o sƒÉn qu√°i"));

        // Generate filename
        const today = new Date();
        const fileName = `BaoCaoSanQuai_${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}.xlsx`;

        // Export file
        XLSX.writeFile(wb, fileName);
        alert(`Xu·∫•t file Excel th√†nh c√¥ng: ${fileName}`);
    } catch (error) {
        console.error("L·ªói khi xu·∫•t Excel:", error);
        alert(`L·ªói khi xu·∫•t Excel: ${error.message}`);
    }
}

        function runDebtCheck() {
            if (processedData.length === 0) {
                alert("Vui l√≤ng t·∫£i d·ªØ li·ªáu Excel tr∆∞·ªõc khi ki·ªÉm tra.");
                return;
            }

            const idsToCheck = document.getElementById('debtCheckIds').value
                .split('\n')
                .map(id => id.trim().replace(/\D/g, '')) // L·ªçc ch·ªâ gi·ªØ l·∫°i s·ªë
                .filter(id => id); // B·ªè c√°c d√≤ng r·ªóng

            if (idsToCheck.length === 0) {
                alert("Vui l√≤ng nh·∫≠p √≠t nh·∫•t m·ªôt User ID ƒë·ªÉ ki·ªÉm tra.");
                return;
            }

            const resultsContainer = document.getElementById('debtCheckResults');
            resultsContainer.innerHTML = ''; // X√≥a k·∫øt qu·∫£ c≈©

            const baseWeeklyTarget = 56; // M·ª•c ti√™u qu√°i tu·∫ßn c∆° b·∫£n

            idsToCheck.forEach(id => {
                const user = processedData.find(item => String(item.id) === id);
                let resultHtml = '';

                if (!user) {
                    resultHtml = `
                <div class="debt-result-item">
                    <div class="debt-result-info">
                        <span class="name">ID: ${id}</span>
                    </div>
                    <div class="debt-result-status debt-status-not-found">
                        Kh√¥ng t√¨m th·∫•y
                    </div>
                </div>
            `;
                } else {
                    const currentDebt = Math.max(0, user.target - user.points);
                    let statusClass, statusText;

                    if (currentDebt === 0) {
                        statusClass = 'debt-status-no-debt';
                        statusText = 'Kh√¥ng n·ª£';
                    } else {
                        const newTotalTarget = baseWeeklyTarget + currentDebt;
                        const newRemainingDebt = newTotalTarget - user.points;

                        if (newRemainingDebt <= 0) {
                            statusClass = 'debt-status-sufficient';
                            statusText = `ƒê√É ƒê·ª¶ (SƒÉn: ${user.points} / Y√™u c·∫ßu: ${newTotalTarget})`;
                        } else {
                            statusClass = 'debt-status-in-debt';
                            statusText = `C√íN N·ª¢ ${newRemainingDebt} (SƒÉn: ${user.points} / Y√™u c·∫ßu: ${newTotalTarget})`;
                        }
                    }
                    
                    resultHtml = `
                <div class="debt-result-item">
                    <div class="debt-result-info">
                        <span class="name">${user.name}</span>
                        <span class="id">(${user.id})</span>
                    </div>
                    <div class="debt-result-status ${statusClass}">
                        ${statusText}
                    </div>
                </div>
            `;
                }

                resultsContainer.insertAdjacentHTML('beforeend', resultHtml);
            });

            if (resultsContainer.innerHTML === '') {
                resultsContainer.innerHTML = '<p class="empty">Kh√¥ng c√≥ ID h·ª£p l·ªá n√†o ƒë·ªÉ ki·ªÉm tra.</p>';
            }
        }
        async function loadExcelFromUrl() {
            const rawUrl = document.getElementById('excelUrl').value.trim();
            console.log("URL g·ªëc:", rawUrl); // Log URL g·ªëc

            if (!rawUrl) {
                alert("Vui l√≤ng nh·∫≠p URL Google Sheets!");
                return;
            }

            // --- C·∫£i thi·ªán vi·ªác l·∫•y URL export ---
            let exportUrl = '';
            // Regex c·∫≠p nh·∫≠t ƒë·ªÉ kh·ªõp c·∫£ 'spreadsheets/d/' v√† 'file/d/'
            const googleSheetRegex = /(?:spreadsheets|file)\/d\/([a-zA-Z0-9-_]+)/;
            const match = rawUrl.match(googleSheetRegex);

            if (match && match[1]) {
                // N·∫øu t√¨m th·∫•y ID, t·∫°o URL export chu·∫©n
                const sheetId = match[1];
                // Lu√¥n t·∫°o link export t·ª´ spreadsheets/d/ v√¨ ƒë√≥ l√† endpoint ch√≠nh th·ª©c
                exportUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=xlsx`;
                console.log("ƒê√£ nh·∫≠n d·∫°ng Google Sheet/File ID:", sheetId);
                console.log("URL Export ƒë∆∞·ª£c t·∫°o:", exportUrl);
            } else if (rawUrl.toLowerCase().endsWith('.xlsx') || rawUrl.toLowerCase().endsWith('.xls')) {
                // Gi·∫£ s·ª≠ l√† link tr·ª±c ti·∫øp ƒë·∫øn file .xlsx/.xls (√≠t ph·ªï bi·∫øn, c√≥ th·ªÉ c·∫ßn proxy)
                exportUrl = rawUrl;
                console.log("URL c√≥ v·∫ª l√† link tr·ª±c ti·∫øp t·ªõi file Excel:", exportUrl);
            } else {
                // N·∫øu kh√¥ng nh·∫≠n d·∫°ng ƒë∆∞·ª£c, b√°o l·ªói
                alert("URL kh√¥ng h·ª£p l·ªá. Vui l√≤ng cung c·∫•p link Google Sheets/File h·ª£p l·ªá (ƒë√£ chia s·∫ª c√¥ng khai) ho·∫∑c link tr·ª±c ti·∫øp ƒë·∫øn file .xlsx.");
                return;
            }
            // --- K·∫øt th√∫c c·∫£i thi·ªán URL ---

            // --- Hi·ªÉn th·ªã th√¥ng b√°o ƒëang x·ª≠ l√Ω ---
            const loadButton = document.querySelector('.url-input + .btn-primary'); // T√¨m n√∫t "T·∫£i t·ª´ URL"
            const originalButtonText = loadButton.textContent;
            loadButton.textContent = 'ƒêang t·∫£i...';
            loadButton.disabled = true;
            document.body.style.cursor = 'wait'; // ƒê·ªïi con tr·ªè chu·ªôt

            try {
                // S·ª≠ d·ª•ng proxy (v·∫´n c·∫ßn thi·∫øt cho CORS)
                const proxyUrl = 'https://api.codetabs.com/v1/proxy?quest='; // B·∫°n c√≥ th·ªÉ th·ª≠ proxy kh√°c n·∫øu c·∫ßn
                const fetchUrl = proxyUrl + encodeURIComponent(exportUrl);
                console.log("URL Fetch qua Proxy:", fetchUrl);

                const response = await fetch(fetchUrl, {
                    signal: AbortSignal.timeout(30000) // Th√™m timeout 30 gi√¢y
                });
                console.log("Tr·∫°ng th√°i ph·∫£n h·ªìi:", response.status, response.statusText);
                console.log("Headers ph·∫£n h·ªìi:", Object.fromEntries(response.headers.entries())); // Log headers ƒë·ªÉ ki·ªÉm tra

                // --- Ki·ªÉm tra Content-Type v√† Status ---
                const contentType = response.headers.get('content-type');
                console.log("Content-Type:", contentType);

                if (!response.ok) {
                    // N·∫øu server b√°o l·ªói (status kh√¥ng ph·∫£i 2xx)
                    let errorBody = await response.text().catch(() => 'Kh√¥ng th·ªÉ ƒë·ªçc n·ªôi dung l·ªói');
                    console.error("N·ªôi dung l·ªói t·ª´ proxy/server:", errorBody);
                    // Ki·ªÉm tra xem c√≥ ph·∫£i l·ªói HTML kh√¥ng
                    if (contentType && contentType.includes('text/html')) {
                        // L·ªói nh∆∞ng tr·∫£ v·ªÅ HTML (vd: trang 404, trang ƒëƒÉng nh·∫≠p...)
                        throw new Error(`L·ªói ${response.status}: Nh·∫≠n ƒë∆∞·ª£c trang HTML thay v√¨ file Excel. C√≥ th·ªÉ link sai, c·∫ßn ƒëƒÉng nh·∫≠p ho·∫∑c sheet kh√¥ng ƒë∆∞·ª£c chia s·∫ª c√¥ng khai.`);
                    } else {
                        // L·ªói kh√°c
                        throw new Error(`L·ªói HTTP: ${response.status} ${response.statusText}`);
                    }
                }

                // Ki·ªÉm tra l·∫°i Content-Type ngay c·∫£ khi status l√† OK (200)
                // M·ªôt s·ªë proxy/tr∆∞·ªùng h·ª£p c√≥ th·ªÉ tr·∫£ v·ªÅ HTML v·ªõi status 200
                if (!contentType || !(contentType.includes('spreadsheetml.sheet') || contentType.includes('application/vnd.ms-excel') || contentType.includes('octet-stream'))) {
                    // N·∫øu Content-Type kh√¥ng ph·∫£i l√† Excel ho·∫∑c binary
                    let responseText = '';
                    try {
                        // Th·ª≠ ƒë·ªçc n·ªôi dung xem c√≥ ph·∫£i HTML kh√¥ng
                        const clonedResponse = response.clone(); // Clone ƒë·ªÉ ƒë·ªçc text m√† kh√¥ng ·∫£nh h∆∞·ªüng arrayBuffer
                        responseText = await clonedResponse.text();
                    } catch (e) { console.error("Kh√¥ng th·ªÉ ƒë·ªçc response text ƒë·ªÉ ki·ªÉm tra HTML"); }

                    if (responseText.trim().toLowerCase().startsWith('<html') || responseText.trim().toLowerCase().startsWith('<!doctype html')) {
                        console.error("N·ªôi dung ph·∫£n h·ªìi c√≥ v·∫ª l√† HTML:", responseText.substring(0, 500));
                        throw new Error("L·ªói ƒë·ªãnh d·∫°ng: Nh·∫≠n ƒë∆∞·ª£c HTML thay v√¨ file Excel. H√£y ƒë·∫£m b·∫£o link Google Sheet ƒë∆∞·ª£c chia s·∫ª c√¥ng khai ('Anyone with the link can view').");
                    } else {
                        // Kh√¥ng ph·∫£i HTML nh∆∞ng c≈©ng kh√¥ng ph·∫£i ƒë·ªãnh d·∫°ng Excel mong ƒë·ª£i
                        console.warn(`Content-Type kh√¥ng mong ƒë·ª£i: ${contentType}. V·∫´n th·ª≠ x·ª≠ l√Ω...`);
                    }
                }
                // --- K·∫øt th√∫c ki·ªÉm tra Content-Type ---

                console.log("ƒêang x·ª≠ l√Ω d·ªØ li·ªáu ArrayBuffer...");
                const arrayBuffer = await response.arrayBuffer();
                console.log("ƒê√£ nh·∫≠n ArrayBuffer, k√≠ch th∆∞·ªõc:", arrayBuffer.byteLength);

                // Ki·ªÉm tra file qu√° nh·ªè (th∆∞·ªùng l√† d·∫•u hi·ªáu l·ªói)
                if (arrayBuffer.byteLength < 100) { // Ng∆∞·ª°ng nh·ªè, c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh
                    let potentialErrorText = '';
                    try {
                        // Th·ª≠ gi·∫£i m√£ xem c√≥ ph·∫£i text l·ªói kh√¥ng
                        potentialErrorText = new TextDecoder().decode(arrayBuffer);
                    } catch { }
                    console.error("K√≠ch th∆∞·ªõc file qu√° nh·ªè, c√≥ th·ªÉ l√† l·ªói:", potentialErrorText);
                    throw new Error("T·∫£i file th·∫•t b·∫°i: File nh·∫≠n ƒë∆∞·ª£c qu√° nh·ªè, c√≥ th·ªÉ l√† trang l·ªói ho·∫∑c link kh√¥ng ƒë√∫ng.");
                }

                // Ti·∫øn h√†nh ph√¢n t√≠ch n·∫øu m·ªçi th·ª© c√≥ v·∫ª ·ªïn
                const data = new Uint8Array(arrayBuffer);
                const workbook = XLSX.read(data, { type: 'array' });
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
                console.log("ƒê√£ ph√¢n t√≠ch d·ªØ li·ªáu JSON t·ª´ Excel.");

                // C·∫≠p nh·∫≠t d·ªØ li·ªáu v√† UI
                const searchInput = document.getElementById('searchInput');
                if (searchInput) searchInput.value = '';


                originalData = processData(jsonData);
                processedData = JSON.parse(JSON.stringify(originalData));
                currentTab = 'missing'; // Reset v·ªÅ tab m·∫∑c ƒë·ªãnh
                updateUI();
                alert("T·∫£i file th√†nh c√¥ng!");

            } catch (error) {
                console.error("Chi ti·∫øt l·ªói khi t·∫£i URL:", error);
                // Hi·ªÉn th·ªã th√¥ng b√°o l·ªói c·ª• th·ªÉ h∆°n cho ng∆∞·ªùi d√πng
                let userMessage = `L·ªói t·∫£i URL: ${error.message || "Kh√¥ng r√µ nguy√™n nh√¢n."}`;
                if (error.message && error.message.includes("HTML")) {
                    // N·∫øu l·ªói c√≥ ch·ª©a ch·ªØ HTML, h∆∞·ªõng d·∫´n ki·ªÉm tra chia s·∫ª
                    userMessage += "\nVui l√≤ng ki·ªÉm tra:\n1. Link Google Sheets c√≥ ƒë√∫ng kh√¥ng?\n2. Sheet ƒë√£ ƒë∆∞·ª£c chia s·∫ª c√¥ng khai ('Anyone with the link can view') ch∆∞a?";
                } else if (error.name === 'TimeoutError') {
                    userMessage = "L·ªói: Y√™u c·∫ßu t·∫£i file m·∫•t qu√° nhi·ªÅu th·ªùi gian. Ki·ªÉm tra k·∫øt n·ªëi m·∫°ng ho·∫∑c th·ª≠ l·∫°i.";
                } else if (!navigator.onLine) {
                    userMessage = "L·ªói: Kh√¥ng c√≥ k·∫øt n·ªëi m·∫°ng.";
                }
                alert(userMessage);
            } finally {
                // --- Kh√¥i ph·ª•c n√∫t v√† con tr·ªè ---
                loadButton.textContent = originalButtonText;
                loadButton.disabled = false;
                document.body.style.cursor = 'default';
            }
        }
        // H√†m ki·ªÉm tra URL h·ª£p l·ªá
        function isValidExcelUrl(url) {
            // Cho ph√©p c·∫£ URL th√¥ng th∆∞·ªùng v√† Google Sheets
            return /(\.xlsx?$)|(docs\.google\.com\/spreadsheets\/d\/)/i.test(url);
        }

        // H√†m x·ª≠ l√Ω thay ƒë·ªïi gi√° tr·ªã Qu√°i Tu·∫ßn
        document.addEventListener('change', function (e) {
            if (e.target.classList.contains('target-input')) {
                const id = parseInt(e.target.dataset.id);
                const newTarget = parseInt(e.target.value) || 56;

                const user = processedData.find(item => item.id === id);
                if (user) {
                    user.target = newTarget;
                    calculatePoints(user);
                    updateUI();
                }
            }
        });

        function parseDuration(durationString) {
            if (!durationString) return null;
            durationString = durationString.trim().toLowerCase();
            let totalMs = 0;
            let valid = false;

            // Regex ƒë·ªÉ b·∫Øt c√°c th√†nh ph·∫ßn: days (d), hours (h), minutes (m), seconds (s), v√† HH:MM:SS
            const dayRegex = /(\d+)\s*d/;
            const hourRegex = /(\d+)\s*h/;
            const minRegex = /(\d+)\s*m/;
            const secRegex = /(\d+)\s*s/;
            const timeRegex = /(\d{1,2}):(\d{1,2}):(\d{1,2})/;

            const dayMatch = durationString.match(dayRegex);
            const hourMatch = durationString.match(hourRegex);
            const minMatch = durationString.match(minRegex);
            const secMatch = durationString.match(secRegex);
            const timeMatch = durationString.match(timeRegex);

            if (dayMatch) {
                totalMs += parseInt(dayMatch[1], 10) * 24 * 60 * 60 * 1000;
                valid = true;
            }
            if (hourMatch) {
                totalMs += parseInt(hourMatch[1], 10) * 60 * 60 * 1000;
                valid = true;
            }
            if (minMatch) {
                totalMs += parseInt(minMatch[1], 10) * 60 * 1000;
                valid = true;
            }
            if (secMatch) {
                totalMs += parseInt(secMatch[1], 10) * 1000;
                valid = true;
            }
            if (timeMatch) {
                const hours = parseInt(timeMatch[1], 10);
                const minutes = parseInt(timeMatch[2], 10);
                const seconds = parseInt(timeMatch[3], 10);
                if (hours < 24 && minutes < 60 && seconds < 60) {
                    // Ch·ªâ c·ªông th√™m n·∫øu ch∆∞a c√≥ ph·∫ßn h/m/s ri√™ng l·∫ª ho·∫∑c l√† ph·∫ßn duy nh·∫•t
                    // N·∫øu c√≥ c·∫£ "1h" v√† "10:20:30", ∆∞u ti√™n "10:20:30" n·∫øu n√≥ ƒë·ª©ng sau?
                    // ƒê∆°n gi·∫£n h√≥a: c·ªông d·ªìn n·∫øu c√≥ timeMatch
                    totalMs += (hours * 60 * 60 * 1000) + (minutes * 60 * 1000) + (seconds * 1000);
                    valid = true;
                } else {
                    // Th·ªùi gian kh√¥ng h·ª£p l·ªá (v√≠ d·ª•: 25:70:90)
                    if (!valid) return null; // N·∫øu ch·ªâ c√≥ time kh√¥ng h·ª£p l·ªá th√¨ tr·∫£ v·ªÅ null
                }
            }

            // ƒê·∫∑c bi·ªát x·ª≠ l√Ω tr∆∞·ªùng h·ª£p ch·ªâ c√≥ d·∫°ng HH:MM:SS m√† kh√¥ng c√≥ d/h/m/s
            if (!dayMatch && !hourMatch && !minMatch && !secMatch && timeMatch && valid) {
                // ƒê√£ t√≠nh ·ªü tr√™n
            } else if (!valid) {
                // N·∫øu kh√¥ng kh·ªõp b·∫•t k·ª≥ ƒë·ªãnh d·∫°ng n√†o
                return null;
            }


            return totalMs > 0 ? totalMs : null;
        }
        function startCountdown() {
            const inputElement = document.getElementById('countdownInput');
            const displayElement = document.getElementById('countdownDisplay');
            const durationString = inputElement.value;

            // D·ª´ng b·ªô ƒë·∫øm c≈© n·∫øu ƒëang ch·∫°y
            if (countdownIntervalId) {
                clearInterval(countdownIntervalId);
                countdownIntervalId = null;
            }

            const durationMs = parseDuration(durationString);

            if (durationMs === null) {
                displayElement.textContent = "ƒê·ªãnh d·∫°ng kh√¥ng h·ª£p l·ªá!";
                return;
            }

            countdownTargetTimestamp = Date.now() + durationMs;

            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã ngay l·∫≠p t·ª©c
            updateCountdownDisplay();

            // B·∫Øt ƒë·∫ßu b·ªô ƒë·∫øm m·ªõi
            countdownIntervalId = setInterval(updateCountdownDisplay, 1000); // C·∫≠p nh·∫≠t m·ªói gi√¢y
        }

        function updateCountdownDisplay() {
            const displayElement = document.getElementById('countdownDisplay');
            if (!countdownTargetTimestamp) {
                displayElement.textContent = ""; // X√≥a hi·ªÉn th·ªã n·∫øu kh√¥ng c√≥ target
                return;
            }

            const now = Date.now();
            const remainingMs = countdownTargetTimestamp - now;

            if (remainingMs <= 0) {
                clearInterval(countdownIntervalId);
                countdownIntervalId = null;
                countdownTargetTimestamp = null;
                displayElement.textContent = "‚è∞ H·∫øt gi·ªù!";
                // C√≥ th·ªÉ th√™m √¢m thanh b√°o hi·ªáu ·ªü ƒë√¢y n·∫øu mu·ªën
                // V√≠ d·ª•: new Audio('path/to/sound.mp3').play();
                return;
            }
            // T·∫°o ƒë·ªëi t∆∞·ª£ng Date t·ª´ timestamp ƒë√≠ch
            const targetDate = new Date(countdownTargetTimestamp);

            // L·∫•y c√°c th√†nh ph·∫ßn ng√†y, th√°ng, nƒÉm, gi·ªù, ph√∫t, gi√¢y
            const day = String(targetDate.getDate()).padStart(2, '0');
            const month = String(targetDate.getMonth() + 1).padStart(2, '0'); // Th√°ng b·∫Øt ƒë·∫ßu t·ª´ 0 n√™n c·∫ßn +1
            const year = targetDate.getFullYear();
            const hours = String(targetDate.getHours()).padStart(2, '0');
            const minutes = String(targetDate.getMinutes()).padStart(2, '0');
            const seconds = String(targetDate.getSeconds()).padStart(2, '0');

            // ƒê·ªãnh d·∫°ng chu·ªói hi·ªÉn th·ªã ng√†y gi·ªù c·ª• th·ªÉ
            const displayText = `H·∫πn ƒë·∫øn: ${day}/${month}/${year} ${hours}:${minutes}:${seconds}`;
            displayElement.textContent = displayText;
        }

        // === K·∫æT TH√öC TH√äM M·ªöI ===

        function exportMissingIdsToTxt() {
    if (!processedData || processedData.length === 0) {
        alert("Ch∆∞a c√≥ d·ªØ li·ªáu. Vui l√≤ng t·∫£i file Excel tr∆∞·ªõc.");
        return;
    }

    const missingIds = processedData
    .filter(item => item.status === 'missing')
    .map(item => ({
        id: item.id,
        debt: (item.target - item.points) + 5 // L·∫•y gi√° tr·ªã t·ª´ logic c·ªôt "B√π"
    }));

    if (missingIds.length === 0) {
    alert("Kh√¥ng c√≥ ID n√†o ·ªü tr·∫°ng th√°i 'Thi·∫øu' ƒë·ªÉ xu·∫•t.");
    return;
    }

    // T·∫°o n·ªôi dung file CSV
    const csvContent = "User ID,S·ªë qu√°i c·∫ßn b√π\n" +
    missingIds.map(item => `${item.id},${item.debt}`).join('\n');

    // L·∫•y ng√†y hi·ªán t·∫°i v√† ƒë·ªãnh d·∫°ng t√™n file
    const today = new Date();
    const day = String(today.getDate()).padStart(2, '0');
    const month = String(today.getMonth() + 1).padStart(2, '0'); // Th√°ng b·∫Øt ƒë·∫ßu t·ª´ 0
    const year = today.getFullYear();
    const fileName = `${day}-${month}-${year}.txt`;

    const blob = new Blob([csvContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    a.click();
    
    URL.revokeObjectURL(url);
    console.log(`ƒê√£ xu·∫•t file ${fileName}`);
}

function runDebtCheck() {
    const fileInput = document.getElementById('debtCheckFile');

    if (fileInput.files.length === 0) {
        alert("Vui l√≤ng ch·ªçn file TXT ch·ª©a th√¥ng tin n·ª£.");
        return;
    }

    const file = fileInput.files[0];
    const reader = new FileReader();

    reader.onload = function (e) {
        const fileContent = e.target.result;
        const debtData = parseDebtData(fileContent);
        if (debtData) {
            displayDebtResults(debtData);
        } else {
            alert("L·ªói: ƒê·ªãnh d·∫°ng file TXT kh√¥ng h·ª£p l·ªá.");
        }
    };

    reader.readAsText(file);
}

function parseDebtData(fileContent) {
    const lines = fileContent.trim().split('\n');
    if (lines.length < 2) return null; // √çt nh·∫•t ph·∫£i c√≥ header v√† 1 d√≤ng d·ªØ li·ªáu

    const header = lines.shift().trim();
    if (header !== "User ID,S·ªë qu√°i c·∫ßn b√π") return null; // Ki·ªÉm tra header

    const debtData = [];
    for (const line of lines) {
        const [id, debt] = line.trim().split(',');
        if (!id || !debt || isNaN(parseInt(debt))) return null; // Ki·ªÉm tra d·ªØ li·ªáu h·ª£p l·ªá
        debtData.push({ id: id.trim(), debt: parseInt(debt) });
    }
    return debtData;
}

function displayDebtResults(debtData) {
    const resultsContainer = document.getElementById('debtCheckResults');
    resultsContainer.innerHTML = '';

    if (!debtData || debtData.length === 0) {
        resultsContainer.innerHTML = '<p class="empty">Kh√¥ng c√≥ d·ªØ li·ªáu n·ª£.</p>';
        return;
    }

    // L·∫•y d·ªØ li·ªáu ng∆∞·ªùi ch∆°i t·ª´ processedData (ƒë√£ ƒë∆∞·ª£c t·∫£i t·ª´ file Excel)
    if (!processedData || processedData.length === 0) {
        resultsContainer.innerHTML = '<p class="empty">Vui l√≤ng t·∫£i file Excel ch·ª©a d·ªØ li·ªáu ng∆∞·ªùi ch∆°i tr∆∞·ªõc.</p>';
        return;
    }

    const results = debtData.map(debtItem => {
        const user = processedData.find(u => String(u.id) === String(debtItem.id));
        if (user) {
            const currentDebt = Math.max(0, user.target - user.points);
            const newTotalTarget = debtItem.debt + 56; // C·ªông th√™m 56 v√†o s·ªë n·ª£
            const newRemainingDebt = Math.max(0, newTotalTarget - user.points);
            return {
                id: user.id,
                name: user.name,
                status: newRemainingDebt <= 0 ? "ƒê√É ƒê·ª¶" : `C√íN N·ª¢ ${newRemainingDebt}`,
                points: user.points,
                required: newTotalTarget
            };
        } else {
            return { id: debtItem.id, name: '', status: "Kh√¥ng t√¨m th·∫•y", points: 0, required: 0 };
        }
    });

    // S·∫Øp x·∫øp k·∫øt qu·∫£ theo th·ª© t·ª±: N·ª£ -> ƒê·ªß -> Kh√¥ng t√¨m th·∫•y
    results.sort((a, b) => {
        const getPriority = (status) => {
            if (status.startsWith("C√íN N·ª¢")) {
                return 1; // ∆Øu ti√™n cao nh·∫•t
            }
            if (status.startsWith("ƒê√É ƒê·ª¶")) {
                return 2; // ∆Øu ti√™n th·ª© hai
            }
            if (status === "Kh√¥ng t√¨m th·∫•y") {
                return 3; // ∆Øu ti√™n th·∫•p nh·∫•t
            }
            return 4; // M·∫∑c ƒë·ªãnh
        };
        return getPriority(a.status) - getPriority(b.status);
    });

     let tableHtml = `
         <div class="table-responsive">
             <table>
                 <thead>
                     <tr>
                         <th>ID</th>
                         <th>T√™n</th>
                         <th>Tr·∫°ng th√°i</th>
                         <th>ƒêi·ªÉm sƒÉn</th>
                         <th>Y√™u c·∫ßu</th>
                     </tr>
                 </thead>
                 <tbody>`;

     results.forEach(item => {
         const statusClass = item.status === "Kh√¥ng t√¨m th·∫•y" ? "debt-status-not-found" : (item.status.startsWith("ƒê√É ƒê·ª¶") ? "debt-status-sufficient" : "debt-status-in-debt");
         tableHtml += `
                     <tr>
                         <td>${item.id}</td>
                         <td>${item.name || ''}</td>
                         <td class="${statusClass}">${item.status}</td>
                         <td>${item.points || 0}</td>
                         <td>${item.required || 0}</td>
                     </tr>`;
     });

     tableHtml += `
                 </tbody>
             </table>
         </div>`;
     resultsContainer.innerHTML = tableHtml;
 }
    </script>
</body>

</html>
